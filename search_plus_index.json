{"./":{"url":"./","title":"Introduction","keywords":"","body":"golang-notes Golang 学习笔记 Summary Introduction 1. Golang介绍 1.1. Golang介绍 1.2. Goalng安装 2. 顺序编程 2.1. 程序结构 2.2. 基本类型 2.3. 流程控制 2.4. 函数 2.5. 错误处理 3. 面向对象编程 3.1. 概述 3.2. 方法 3.3. 接口 3.4. 指针 4. 并发编程 4.1. 并发基础 4.2. Goroutine 4.3. Channel 4.4. 并行化 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 18:10:06 "},"introduction/golang.html":{"url":"introduction/golang.html","title":"Golang介绍","keywords":"","body":"初识Go语言 1. 概述 一个在语言层面实现了并发机制的类C通用型编程语言。 2. Go关键字（25个） 类别 关键字 说明 程序声明 package，import 包的声明和导入 声明与定义 var，const 变量和常量的声明 type 用于定义类型 复合数据类型 struct 定义结构体，类似java中的class interface 定义接口 map 定义键值对 func 定义函数和方法 chan 定义管道，并发中channel通信 并发编程 go 并发编程 select 用于选择不同类型通信 流程控制 for；if，else；switch，case 循环语句；条件语句；选择语句 break，continue，fallthrough，default，goto 跳转语句等 return 函数返回值 defer 延迟函数，用于return前释放资源 range 用于读取slice，map，channel容器类数据 3. Go语言命令 Usage：go command [arguments] 分类 命令 说明 build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:56:22 "},"introduction/install.html":{"url":"introduction/install.html","title":"Goalng安装","keywords":"","body":"1. install-go.sh #!/bin/bash # for linux set -x set -e # default version: 1.10.3 VERSION=$1 VERSION=${VERSION:-1.10.3} GOROOT=\"/usr/local/go\" GOPATH=$HOME/gopath # download and install wget https://dl.google.com/go/go${VERSION}.linux-amd64.tar.gz tar -C /usr/local -xzf go${VERSION}.linux-amd64.tar.gz # set golang env cat >> $HOME/.bashrc 2. 安装 chmod +x install-go.sh ./install-go.sh 1.10.3 更多版本号可参考：https://golang.org/dl/ 参考： https://golang.org/doc/install Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 18:02:10 "},"introduction/package/govendor-usage.html":{"url":"introduction/package/govendor-usage.html","title":"govendor的使用","keywords":"","body":"1. govendor简介 golang工程的依赖包经常使用go get 的方式来获取，例如：go get github.com/kardianos/govendor ，会将依赖包下载到GOPATH的路径下。 常用的依赖包管理工具有godep，govendor等，在Golang1.5之后，Go提供了 GO15VENDOREXPERIMENT 环境变量，用于将go build时的应用路径搜索调整成为 当前项目目录/vendor 目录方式。通过这种形式，我们可以实现类似于 godep 方式的项目依赖管理。 2. 安装与使用 2.1. 安装 go get -u -v github.com/kardianos/govendor 2.2. 使用 #进入到项目目录 cd /home/gopath/src/mytool #初始化vendor目录 govendor init #查看vendor目录 [root@CC54425A mytool]# ls commands main.go vendor mytool_test.sh #进入vendor目录 cd vendor #将GOPATH中本工程使用到的依赖包自动移动到vendor目录中 #说明：如果本地GOPATH没有依赖包，先go get相应的依赖包 govendor add +external #通过设置环境变量 GO15VENDOREXPERIMENT=1 使用vendor文件夹构建文件。 #可以选择 export GO15VENDOREXPERIMENT=1 或 GO15VENDOREXPERIMENT=1 go build 执行编译 export GO15VENDOREXPERIMENT=1 2.3. 说明 govendor只是用来管理项目的依赖包，如果GOPATH中本身没有项目的依赖包，则需要通过go get先下载到GOPATH中，再通过govendor add +external 拷贝到vendor目录中。 3. govendor使用命令 [root@CC54425A mytool]# govendor govendor (v1.0.8): record dependencies and copy into vendor folder -govendor-licenses Show govendor's licenses. -version Show govendor version -cpuprofile 'file' Writes a CPU profile to 'file' for debugging. -memprofile 'file' Writes a heap profile to 'file' for debugging. Sub-Commands init Create the \"vendor\" folder and the \"vendor.json\" file. list List and filter existing dependencies and packages. add Add packages from $GOPATH. update Update packages from $GOPATH. remove Remove packages from the vendor folder. status Lists any packages missing, out-of-date, or modified locally. fetch Add new or update vendor folder packages from remote repository. sync Pull packages into vendor folder from remote repository with revisions from vendor.json file. migrate Move packages from a legacy tool to the vendor folder with metadata. get Like \"go get\" but copies dependencies into a \"vendor\" folder. license List discovered licenses for the given status or import paths. shell Run a \"shell\" to make multiple sub-commands more efficient for large projects. go tool commands that are wrapped: \"+status\" package selection may be used with them fmt, build, install, clean, test, vet, generate, tool Status Types +local (l) packages in your project +external (e) referenced packages in GOPATH but not in current project +vendor (v) packages in the vendor folder +std (s) packages in the standard library +excluded (x) external packages explicitly excluded from vendoring +unused (u) packages in the vendor folder, but unused +missing (m) referenced packages but not found +program (p) package is a main package +outside +external +missing +all +all packages Status can be referenced by their initial letters. Package specifier [::][{/...|/^}][@[]] Ignoring files with build tags, or excluding packages from being vendored: The \"vendor.json\" file contains a string field named \"ignore\". It may contain a space separated list of build tags to ignore when listing and copying files. This list may also contain package prefixes (containing a \"/\", possibly as last character) to exclude when copying files in the vendor folder. If \"foo/\" appears in this field, then package \"foo\" and all its sub-packages (\"foo/bar\", …) will be excluded (but package \"bar/foo\" will not). By default the init command adds the \"test\" tag to the ignore list. If using go1.5, ensure GO15VENDOREXPERIMENT=1 is set. 4. vendor.json { \"comment\": \"\", \"ignore\": \"test\", \"package\": [ { \"checksumSHA1\": \"uGalSICR4r7354vvKuNnh7Y/R/4=\", \"path\": \"github.com/urfave/cli\", \"revision\": \"b99aa811b4c1dd84cc6bccb8499c82c72098085a\", \"revisionTime\": \"2017-08-04T09:34:15Z\" } ], \"rootPath\": \"mytool\" } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:54:55 "},"introduction/package/dep-usage.html":{"url":"introduction/package/dep-usage.html","title":"dep的使用","keywords":"","body":"1. dep简介 dep是一个golang项目的包管理工具，一般只需要2-3个命令就可以将go依赖包自动下载并归档到vendor的目录中。dep官网参考：https://github.com/golang/dep 2. dep安装 go get -u github.com/golang/dep/cmd/dep 3. dep使用 #进入到项目目录 cd /home/gopath/src/demo #dep初始化，初始化配置文件Gopkg.toml dep init #dep加载依赖包，自动归档到vendor目录 dep ensure # 最终会生成vendor目录，Gopkg.toml和Gopkg.lock的文件 4. dep的配置文件 Gopkg.toml记录依赖包列表。 # Gopkg.toml example # # Refer to https://golang.github.io/dep/docs/Gopkg.toml.html # for detailed Gopkg.toml documentation. # # required = [\"github.com/user/thing/cmd/thing\"] # ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"] # # [[constraint]] # name = \"github.com/user/project\" # version = \"1.0.0\" # # [[constraint]] # name = \"github.com/user/project2\" # branch = \"dev\" # source = \"github.com/myfork/project2\" # # [[override]] # name = \"github.com/x/y\" # version = \"2.4.0\" # # [prune] # non-go = false # go-tests = true # unused-packages = true ignored = [\"demo\"] [[constraint]] name = \"github.com/BurntSushi/toml\" version = \"0.3.0\" [prune] go-tests = true unused-packages = true 5. dep-help 更多dep的命令帮助参考dep。 $ dep Dep is a tool for managing dependencies for Go projects Usage: \"dep [command]\" Commands: init Set up a new Go project, or migrate an existing one status Report the status of the project's dependencies ensure Ensure a dependency is safely vendored in the project prune Pruning is now performed automatically by dep ensure. version Show the dep version information Examples: dep init set up a new project dep ensure install the project's dependencies dep ensure -update update the locked versions of all dependencies dep ensure -add github.com/pkg/errors add a dependency to the project Use \"dep help [command]\" for more information about a command. Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:54:33 "},"introduction/package/glide-usage.html":{"url":"introduction/package/glide-usage.html","title":"glide的使用","keywords":"","body":"1. glide简介 glide是一个golang项目的包管理工具，非常方便快捷，一般只需要2-3个命令就可以将go依赖包自动下载并归档到vendor的目录中。 2. glide安装 go get github.com/Masterminds/glide 3. glide使用 #进入到项目目录 cd /home/gopath/src/demo #glide初始化，初始化配置文件glide.yaml glide init #glide加载依赖包，自动归档到vendor目录 glide up -v 4. glide的配置文件 glide.yaml记录依赖包列表。 package: demo import: - package: github.com/astaxie/beego version: v1.9.2 testImport: - package: github.com/smartystreets/goconvey version: 1.6.3 subpackages: - convey 5. glide-help 更多glide的命令帮助参考glide —help。 ➜ demo glide --help NAME: glide - Vendor Package Management for your Go projects. Each project should have a 'glide.yaml' file in the project directory. Files look something like this: package: github.com/Masterminds/glide imports: - package: github.com/Masterminds/cookoo version: 1.1.0 - package: github.com/kylelemons/go-gypsy subpackages: - yaml For more details on the 'glide.yaml' files see the documentation at https://glide.sh/docs/glide.yaml USAGE: glide [global options] command [command options] [arguments...] VERSION: 0.13.2-dev COMMANDS: create, init Initialize a new project, creating a glide.yaml file config-wizard, cw Wizard that makes optional suggestions to improve config in a glide.yaml file. get Install one or more packages into `vendor/` and add dependency to glide.yaml. remove, rm Remove a package from the glide.yaml file, and regenerate the lock file. import Import files from other dependency management systems. name Print the name of this project. novendor, nv List all non-vendor paths in a directory. rebuild Rebuild ('go build') the dependencies install, i Install a project's dependencies update, up Update a project's dependencies tree (Deprecated) Tree prints the dependencies of this project as a tree. list List prints all dependencies that the present code references. info Info prints information about this project cache-clear, cc Clears the Glide cache. about Learn about Glide mirror Manage mirrors help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --yaml value, -y value Set a YAML configuration file. (default: \"glide.yaml\") --quiet, -q Quiet (no info or debug messages) --debug Print debug verbose informational messages --home value The location of Glide files (default: \"/Users/meitu/.glide\") [$GLIDE_HOME] --tmp value The temp directory to use. Defaults to systems temp [$GLIDE_TMP] --no-color Turn off colored output for log messages --help, -h show help --version, -v print the version Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:54:39 "},"basis/program-structure.html":{"url":"basis/program-structure.html","title":"程序结构","keywords":"","body":"1.变量 1.1变量声明 //1、单变量声明,类型放在变量名之后，可以为任意类型 var 变量名 类型 var v1,v2,v3 string //多变量同类型声明 //2、多变量声明 var { v1 int v2 []int } 1.2变量初始化 //1、使用关键字var，声明变量类型并赋值 var v1 int=10 //2、使用关键字var，直接对变量赋值，go可以自动推导出变量类型 var v2=10 //3、直接使用“：=”对变量赋值，不使用var，两者同时使用会语法冲突，推荐使用 v3:=10 1.3变量赋值 //1、声明后再变量赋值 var v int v=10 //2、多重赋值，经常使用在函数的多返回值中，err,v=func(arg) i，j=j,i //两者互换，并不需要引入中间变量 1.4匿名变量 //Go中所有声明后的变量都需要调用到，当出现函数多返回值，并且部分返回值不需要使用时，可以使用匿名变量丢弃该返回值 func GetName()(firstName,lastName,nickName string){ return \"May\",\"Chan\",\"Make\" } _,_,nickName:=GetName() //使用匿名变量丢弃部分返回值 2.常量 ​ Go语言中，常量是编译时期就已知且不可变的值，常量可以是数值类型（整型、浮点型、复数类型）、布尔类型、字符串类型。 2.1字面常量 //字面常量(literal)指程序中硬编码的常量 3.14 “foo” true 2.2常量定义 //1、可以限定常量类型，但非必需 const Pi float64 = 3.14 //2、无类型常量和字面常量一样 const zero=0.0 //3、多常量赋值 const( size int64=1024 eof=-1 ) //4、常量的多重赋值，类似变量的多重赋值 const u,v float32=0,3 const a,b,c=3,4,\"foo\" //无类型常量的多重赋值 //5、常量赋值是编译期行为，可以赋值为一个编译期运算的常量表达式 const mask=1 2.3预定义常量 //预定义常量：true、false、iota //iota：可修改常量，在每次const出现时被重置为0，在下一个const出现前，每出现一次iota，其代表的值自动增1。 const( //iota重置为0 c0=iota //c0==0 c1=iota //c1==1 c2=iota //c2==2 ) //两个const赋值语句一样可以省略后一个 const( //iota重置为0 c0=iota //c0==0 c1 //c1==1 c2 //c2==2 ) 2.4枚举 枚举指一系列相关常量。 const( Sunday=iota //Sunday==0,以此类推 Monday Tuesday Wednesday Thursday Friday Saturday //大写字母开头表示包外可见 numberOfDays //小写字母开头表示包内私有 ) Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:20:38 "},"basis/data-types.html":{"url":"basis/data-types.html","title":"基本类型","keywords":"","body":"类型 1. 基础类型 1.1. 布尔类型 //布尔类型的关键字为bool,值为true或false，不可写为0或1 var v1 bool v1=true //接受表达式判断赋值，不支持自动或强制类型转换 v2:=(1==2) 1.2. 整型 //1、类型表示 //int和int32为不同类型，不会自动类型转换需要强制类型转换 //强制类型转换需注意精度损失（浮点数→整数），值溢出（大范围→小范围） var v2 int32 v1:=64 v2=int32(v1) //2、数值运算,支持“+,-,*,/和%” 5%3 //求余 //3、比较运算,“,==,>=, 图片 - 这里写图片描述 1.3. 浮点型 //1、浮点型分为float32(类似C中的float)，float64(类似C中的double) var f1 float32 f1=12 //不加小数点，被推导为整型 f2:=12.0 //加小数点，被推导为float64 f1=float32(f2) //需要执行强制转换 //2、浮点数的比较 //浮点数不是精确的表达方式，不能直接使用“==”来判断是否相等，可以借用math的包math.Fdim 1.4. 复数类型 //1、复数的表示 var v1 complex64 v1=3.2+12i //v1 v2 v3 表示为同一个数 v2:=3.2+12i v3:=complex(3.2,12) //2、实部与虚部 //z=complex(x,y),通过内置函数实部x=real(z),虚部y=imag(z) 1.5. 字符串 //声明与赋值 var str string str=\"hello world\" 图片 - 这里写图片描述 1.6. 字符类型 //1、byte，即uint8的别名 //2、rune，即Unicode 1.7. 错误类型（error） 2. 复合类型 2.1. 数组(array) 数组表示同一类型数据，数组长度定义后就不可更改，长度是数组内的一个内置常量，可通过len()来获取。 //1、创建数组 var array1 [5]int //声明：var 变量名 类型 var array2 [5]int=[5]int{1,2,3,4,5} //初始化 array3：=[5]int{1,2,3,4,5} //直接用“：=”赋值 [3][5]int //二维数组 [3]*float //指针数组 //2、元素访问 for i,v:=range array{ //第一个返回值为数组下标，第二个为元素的值 } //3、值类型 //数组在Go中作为一个值类型，值类型在赋值和函数参数传递时，只复制副本，因此在函数体中并不能改变数组的内容，需用指针来改变数组的值。 2.2. 切片(slice) ​ 数组在定义了长度后无法改变，且作为值类型在传递时产生副本，并不能改变数组元素的值。因此切片的功能弥补了这个不足，切片类似指向数组的一个指针。可以抽象为三个变量：指向数组的指针；切片中元素的个数(len函数)；已分配的存储空间(cap函数)。 //1、创建切片 //a)基于数组创建 var myArray [5]int=[5]{1,2,3,4,5} var mySlice []int=myArray[first:last] slice1=myArray[:] //基于数组所有元素创建 slice2=myArray[:3] //基于前三个元素创建 slice3=myArray[3:] //基于第3个元素开始后的所有元素创建 //b)直接创建 slice1:=make([]int,5) //元素初始值为0，初始个数为5 slice2:=make([]int,5,10) //元素初始值为0，初始个数为5，预留个数为10 slice3:=[]int{1,2,3,4,5} //初始化赋值 //c)基于切片创建 oldSlice:=[]int{1,2,3,4,5} newSlice:=oldSlice[:3] //基于切片创建，不能超过原切片的存储空间(cap函数的值) //2、元素遍历 for i,v:=range slice{ //与数组的方式一致，使用range来遍历 //第一个返回值(i)为索引，第二个为元素的值(v) } //3、动态增减元素 //切片分存储空间(cap)和元素个数(len)，当存储空间小于实际的元素个数，会重新分配一块原空间2倍的内存块，并将原数据复制到该内存块中，合理的分配存储空间可以以空间换时间，降低系统开销。 //添加元素 newSlice:=append(oldSlice,1,2,3) //直接将元素加进去，若存储空间不够会按上述方式扩容。 newSlice1:=append(oldSlice1,oldSlice2...) //将oldSlice2的元素打散后加到oldSlice1中，三个点不可省略。 //4、内容复制 //copy()函数可以复制切片，如果切片大小不一样，按较小的切片元素个数进行复制 slice1:=[]int{1,2,3,4,5} slice2:=[]int{6,7,8} copy(slice2,slice1) //只会复制slice1的前三个元素到slice2中 copy(slice1,slice1) //只会复制slice2的三个元素到slice1中的前三个位置 2.3. 键值对(map) map是一堆键值对的未排序集合。 //1、先声明后创建再赋值 var map1 map[键类型] 值类型 //创建 map1=make(map[键类型] 值类型) map1=make(map[键类型] 值类型 存储空间) //赋值 map1[key]=value // 直接创建 m2 := make(map[string]string) // 然后赋值 m2[\"a\"] = \"aa\" m2[\"b\"] = \"bb\" // 初始化 + 赋值一体化 m3 := map[string]string{ \"a\": \"aa\", \"b\": \"bb\", } //2、元素删除 //delete()函数删除对应key的键值对，如果key不存在，不会报错；如果value为nil，则会抛出异常(panic)。 delete(map1,key) //3、元素查找 value,ok:=myMap[key] if ok{//如果找到 //处理找到的value值 } //遍历 for key,value:=range myMap{ //处理key或value } map可以用来判断一个值是否在切片或数组中。 // 判断某个类型（假如为myType）的值是否在切片或数组（假如为myList）中 // 构造一个map,key的类型为myType,value为bool型 myMap := make(map[myType]bool) myList := []myType{value1, value2} // 将切片中的值存为map中的key（因为key不能重复）,map的value都为true for _, value := range myList { myMap[value] = true } // 判断valueX是否在myList中，即判断其是否在myMap的key中 if _, ok := myMap[valueX]; ok { // 如果valueX 在myList中，执行后续操作 } 2.4. 指针(pointer) 具体参考Go语言指针详解 2.5. 结构体(struct) 具体参考Go面向对象编程之结构体 2.6. 接口(interface) 具体参考Go面向对象编程之接口 2.7. 通道(chan) 具体参考Go并发编程之channel Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:19:40 "},"basis/control-structures.html":{"url":"basis/control-structures.html","title":"流程控制","keywords":"","body":"流程控制 1. 条件语句 //在if之后条件语句之前可以添加变量初始化语句，用;号隔离 if { //条件语句不需要用括号括起来，花括号必须存在 //语句体 }else{ //语句体 } //在有返回值的函数中，不允许将最后的return语句放在if...else...的结构中，否则会编译失败 //例如以下为错误范例 func example(x int) int{ if x==0{ return 5 }else{ return x //最后的return语句放在if-else结构中，所以编译失败 } } 2. 选择语句 //1、根据条件不同，对应不同的执行体 switch i{ case 0: fmt.Printf(\"0\") case 1: //满足条件就会退出，只有添加fallthrough才会继续执行下一个case语句 fmt.Prinntf(\"1\") case 2,3,1: //单个case可以出现多个选项 fmt.Printf(\"2,3,1\") default: //当都不满足以上条件时，执行default语句 fmt.Printf(\"Default\") } //2、该模式等价于多个if-else的功能 switch { case : 语句体1 case : 语句体2 } 3. 循环语句 //1、Go只支持for关键字，不支持while，do-while结构 for i,j:=0,1;i 100{ break //满足条件跳出循环 } } //3、支持continue和break，break可以指定中断哪个循环，break JLoop(标签) for j:=0;j5{ break JLoop //终止JLoop标签处的外层循环 } fmt.Println(i) } JLoop: //标签处 ... 4. 跳转语句 //关键字goto支持跳转 func myfunc(){ i:=0 HERE: //定义标签处 fmt.Println(i) i++ if i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:24:06 "},"basis/functions.html":{"url":"basis/functions.html","title":"函数","keywords":"","body":"函数 1. 函数定义与调用 //1、函数组成：关键字func ,函数名，参数列表，返回值，函数体，返回语句 //先名称后类型 func 函数名(参数列表)(返回值列表){ //参数列表和返回值列表以变量声明的形式，如果单返回值可以直接加类型 函数体 return //返回语句 } //例子 func Add(a,b int)(ret int,err error){ //函数体 return //return语句 } //2、函数调用 //先导入函数所在的包，直接调用函数 import \"mymath\" sum,err:=mymath.Add(1,2) //多返回值和错误处理机制 //可见性，包括函数、类型、变量 //本包内可见(private)：小写字母开头 //包外可见(public)：大写字母开头 2. 不定参数 //1、不定参数的类型 func myfunc(args ...int){ //...type不定参数的类型，必须是最后一个参数，本质是切片 for _,arg:=range args{ fmt.Println(arg) } } //函数调用,传参可以选择多个，个数不定 myfunc(1,2,3) myfunc(1,2,3,4,5) //2、不定参数的传递，假如有个变参函数myfunc2(args ...int) func myfunc1(args ...int){ //按原样传递 myfunc2(args...) //传递切片 myfunc2(args[1:]...) } //3、任意类型的不定参数，使用interface{}作为指定类型 func Printf(format string,args ...interface{}){ //此为标准库中fmt.Printf()函数的原型 //函数体 } 3. 多返回值 //多返回值 func (file *File) Read(b []byte) (n int,err error) //使用下划线\"_\"来丢弃返回值 n,_:=f.Read(buf) 4. 匿名函数与闭包 //1、匿名函数：不带函数名的函数，可以像变量一样被传递 func(a,b int,z float32) bool{ //没有函数名 return a*b Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:14:36 "},"basis/errors.html":{"url":"basis/errors.html","title":"错误处理","keywords":"","body":"错误处理 1、error接口 //定义error接口 type error interface{ Error() string } //调用error接口 func Foo(param int) (n int,err error){ //... } n,err:=Foo(0) if err!=nil{ //错误处理 }else{ //使用返回值 } 2、defer[延迟函数] 语法：defer function_name() 1）defer在声明时不会执行，而是推迟执行，在return执行前，倒序执行defer[先进后出]，一般用于释放资源，清理数据，记录日志，异常处理等。 2）defer有一个特性：即使函数抛出异常，defer仍会被执行，这样不会出现程序错误导致资源不被释放，或者因为第三方包的异常导致程序崩溃。 3）一般用于打开文件后释放资源的操作，比如打开一个文件，最后总是要关闭的。而在打开和关闭之间，会有诸多的处理，可能会有诸多的if-else、根据不同的情况需要提前返回 f, = os.open(filename) defer f.close() do_something() if (condition_a) {return} do_something_again() if (condition_b) {return} do_further_things() 4）defer示例 package main import \"fmt\" func deferTest(number int) int { defer func() { number++ fmt.Println(\"three:\", number) }() defer func() { number++ fmt.Println(\"two:\", number) }() defer func() { number++ fmt.Println(\"one:\", number) }() return number } func main() { fmt.Println(\"函数返回值：\", deferTest(0)) } /* one: 1 two: 2 three: 3 函数返回值： 0 */ Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:23:15 "},"oop/oop.html":{"url":"oop/oop.html","title":"概述","keywords":"","body":"面向对象编程 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）[方法的重写，子类不同于父类的特性]／泛化（generalization）[共性，子类都拥有父类的特性]，通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。 面对对象思想 面向对象思想是对现实世界事物的抽象，系统中一切事物皆为对象；对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:51:53 "},"oop/method.html":{"url":"oop/method.html","title":"方法","keywords":"","body":"1. 类型系统[类的声明] 类型系统： 一组基本类型构成的“基本类型集合”； “基本类型集合”上定义的一系列组合、运算、转换方法。 类型系统包括基础类型（byte、int、bool、float等）；复合类型（数组、结构体、指针等）；可以指向任何对象的类型（Any类型，类似Java的Object类型）；值语义和引用语义；面向对象类型；接口。Go大多数类型为值语义，可以给任何类型添加方法（包括内置类型，不包括指针类型）。Any类型是空接口即interface{}。 2. 结构体 结构体[类属性的声明] struct的功能类似Java的class，可实现嵌套组合(类似继承的功能) struct实际上就是一种复合类型，只是对类中的属性进行定义赋值，并没有对方法进行定义，方法可以随时定义绑定到该类的对象上，更具灵活性。可利用嵌套组合来实现类似继承的功能避免代码重复。 type Rect struct{ //定义矩形类 x,y float64 //类型只包含属性，并没有方法 width,height float64 } func (r *Rect) Area() float64{ //为Rect类型绑定Area的方法，*Rect为指针引用可以修改传入参数的值 return r.width*r.height //方法归属于类型，不归属于具体的对象，声明该类型的对象即可调用该类型的方法 } 3. 方法 1、为类型添加方法[类方法声明]，方法即为有接收者的函数 func (对象名 对象类型) 函数名(参数列表) (返回值列表) 可随时为某个对象添加方法即为某个方法添加归属对象（receiver），以方法为中心 在Go语言中没有隐藏的this指针，即显示传递，形参即为this，例如以下的形参为a。 type Integer int func (a Integer) Less(b Integer) bool{ //表示a这个对象定义了Less这个方法，a可以为任意类型 return a 4. 值语义和引用语义 值类型：b的修改并不会影响a的值 引用类型：b的修改会影响a的值 Go大多类型为值语义，包括基本类型：byte，int，string等；复合类型：数组，结构体(struct)，指针等 //2、值语义和引用语义 b=a b.Modify() //值类型 var a=[3]int{1,2,3} b:=a b[1]++ fmt.Println(a,b) //a=[1,2,3] b=[1,3,3] //引用类型 a:=[3]int{1,2,3} b:=&a //b指向a,即为a的地址，对b指向的值改变实际上就是对a的改变（数组本身就是一种地址指向） b[1]++ fmt.Println(a,*b) //a=[1,3,3] b=[1,3,3] //*b,取地址指向的值 5. 初始化[实例化对象] 数据初始化的内建函数new()与make()，二者都是用来分配空间。区别如下: 5.1. new() func new(Type) *Type 内置函数 new 分配空间。传递给new 函数的是一个类型，不是一个值。返回值是指向这个新分配的零值的指针 5.2. make() func make(Type, size IntegerType) Type 内建函数 make 分配并且初始化 一个 slice, 或者 map 或者 chan 对象。 并且只能是这三种对象。 和 new 一样，第一个参数是 类型，不是一个值。 但是make 的返回值就是这个类型（即使一个引用类型），而不是指针。 具体的返回值，依赖具体传入的类型。 5.3. 示例 //创建实例 rect1:=new(Rect) //new一个对象 rect2:=&Rect{} //为赋值默认值，bool默认值为false，int默认为零值0，string默认为空字符串 rect3:=&Rect{0,0,100,200} //取地址并赋值,按声明的变量顺序依次赋值 rect4:=&Rect{width:100,height:200} //按变量名赋值不按顺序赋值 //构造函数：没有构造参数的概念，通常由全局的创建函数NewXXX来实现构造函数的功能 func NewRect(x,y,width,height float64) *Rect{ return &Rect{x,y,width,height} //利用指针来改变传入参数的值达到类似构造参数的效果 } //方法的重载,Go不支持方法的重载（函数同名，参数不同） //v …interface{}表示参数不定的意思，其中v是slice类型，及声明不定参数，可以传入任意参数，实现类似方法的重载 func (poem *Poem) recite(v ...interface{}) { fmt.Println(v) } 6. 匿名组合[继承] ​ 组合，即方法代理，例如A包含B，即A通过消息传递的形式代理了B的方法，而不需要重复写B的方法。 ​ 继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承主要为了代码复用，继承也可以扩展已存在的代码模块（类）。 ​ 严格来讲，继承是“a kind of ”，即子类是父类的一种，例如student是person的一种；组合是“a part of”，即父类是子类中的一部分，例如眼睛是头部的一部分。 //1、匿名组合的方式实现了类似Java继承的功能，可以实现多继承 type Base struct{ Name string } func (base *Base) Foo(){...} //Base的Foo()方法 func (base *Base) Bar(){...} //Base的Bar()方法 type Foo struct{ Base //通过组合的方式声明了基类，即继承了基类 ... } func (foo *Foo) Bar(){ foo.Base.Bar() //并改写了基类的方法，该方法实现时先调用基类的Bar()方法 ... //如果没有改写即为继承，调用foo.Foo()和调用foo.Base.Foo()的作用的一样的 } //修改内存布局 type Foo struct{ ... //其他成员信息 Base } //以指针方式组合 type Foo struct{ *Base //以指针方式派生，创建Foo实例时，需要外部提供一个Base类实例的指针 ... } //名字冲突问题,组合内外如果出现名字重复问题，只会访问到最外层，内层会被隐藏，不会报错，即类似java中方法覆盖/重写。 type X struct{ Name string } type Y struct{ X //Y.X.Name会被隐藏，内层会被隐藏 Name string //只会访问到Y.Name，只会调用外层属性 } 7. 可见性[封装] 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 封装的本质或目的其实程序对信息(数据)的控制力。封装分为两部分：该隐藏的隐藏，该暴露的暴露。封装可以隐藏实现细节，使得代码模块化。 Go中用大写字母开头来表示public，可以包外访问；小写字母开头来表示private，只能包内访问；访问性是包级别非类型级别,如果可访问性是类型一致的，可以加friend关键字表示朋友关系可互相访问彼此的私有成员(属性和方法) type Rect struct{ X,Y float64 Width,Height float64 //字母大写开头表示该属性可以由包外访问到 } func (r *Rect) area() float64{ //字母小写开头表示该方法只能包内调用 return r.Width*r.Height } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 18:06:21 "},"oop/interface.html":{"url":"oop/interface.html","title":"接口","keywords":"","body":"1. 接口[多态] ​多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 简而言之，就是允许将子类类型的指针赋值给父类类型的指针。 即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态分为编译时多态（静态多态）和运行时多态（动态多态），编译时多态一般通过方法重载实现，运行时多态一般通过方法重写实现。 1.1 接口概念 接口类型可以看作是类型系统中一种特殊的类型，而实例就是实现了该接口的具体结构体类型。 接口类型与实现了该接口的结构体对象之间的关系好比变量类型与变量之间的关系。 ​ 接口即一组方法定义的集合，定义了对象的一组行为，由具体的类型实例实现具体的方法。换句话说，一个接口就是定义（规范或约束），而方法就是实现，接口的作用应该是将定义与实现分离，降低耦合度。习惯用“er”结尾来命名，例如“Reader”。接口与对象的关系是多对多，即一个对象可以实现多个接口，一个接口也可以被多个对象实现。 ​ 接口是Go语言整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而Go语言的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明。 接口的比喻 ​ 你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。。。所有的上述硬件都可以公用这个接口，有很好的扩展性，该USB接口定义了一种规范，只要实现了该规范，就可以将不同的设备接入电脑，而设备的改变并不会对电脑本身有什么影响（低耦合）。 面向接口编程 ​ 接口表示调用者和设计者的一种约定，在多人合作开发同一个项目时，事先定义好相互调用的接口可以大大提高开发的效率。接口是用类来实现的，实现接口的类必须严格按照接口的声明来实现接口提供的所有功能。有了接口，就可以在不影响现有接口声明的情况下，修改接口的内部实现，从而使兼容性问题最小化。 ​ 面向接口编程可以分为三方面：制定者（或者叫协调者），实现者（或者叫生产者），调用者（或者叫消费者）。 ​ 当其他设计者调用了接口后，就不能再随意更改接口的定义，否则项目开发者事先的约定就失去了意义。但是可以在类中修改相应的代码，完成需要改动的内容。 1.2 非侵入式接口 非侵入式接口：一个类只需要实现了接口要求的所有函数就表示实现了该接口，并不需要显式声明 type File struct{ //类的属性 } //File类的方法 func (f *File) Read(buf []byte) (n int,err error) func (f *File) Write(buf []byte) (n int,err error) func (f *File) Seek(off int64,whence int) (pos int64,err error) func (f *File) Close() error //接口1：IFile type IFile interface{ Read(buf []byte) (n int,err error) Write(buf []byte) (n int,err error) Seek(off int64,whence int) (pos int64,err error) Close() error } //接口2：IReader type IReader interface{ Read(buf []byte) (n int,err error) } //接口赋值,File类实现了IFile和IReader接口，即接口所包含的所有方法 var file1 IFile = new(File) var file2 IReader = new(File) 1.3 接口赋值 只要类实现了该接口的所有方法，即可将该类赋值给这个接口，接口主要用于多态化方法。即对接口定义的方法，不同的实现方式。 接口赋值： 1）将对象实例赋值给接口 type IUSB interface{ //定义IUSB的接口方法 } //方法定义在类外，绑定该类，以下为方便，备注写在类中 type MP3 struct{ //实现IUSB的接口，具体实现方式是MP3的方法 } type Mouse struct{ //实现IUSB的接口，具体实现方式是Mouse的方法 } //接口赋值给具体的对象实例MP3 var usb IUSB =new(MP3) usb.Connect() usb.Close() //接口赋值给具体的对象实例Mouse var usb IUSB =new(Mouse) usb.Connect() usb.Close() 2）将接口赋值给另一个接口 只要两个接口拥有相同的方法列表（与次序无关），即是两个相同的接口，可以相互赋值 接口赋值只需要接口A的方法列表是接口B的子集（即假设接口A中定义的所有方法，都在接口B中有定义），那么B接口的实例可以赋值给A的对象。反之不成立，即子接口B包含了父接口A，因此可以将子接口的实例赋值给父接口。 即子接口实例实现了子接口的所有方法，而父接口的方法列表是子接口的子集，则子接口实例自然实现了父接口的所有方法，因此可以将子接口实例赋值给父接口。 type Writer interface{ //父接口 Write(buf []byte) (n int,err error) } type ReadWriter interface{ //子接口 Read(buf []byte) (n int,err error) Write(buf []byte) (n int,err error) } var file1 ReadWriter=new(File) //子接口实例 var file2 Writer=file1 //子接口实例赋值给父接口 1.4 接口查询 若要在 switch 外判断一个接口类型是否实现了某个接口，可以使用“逗号 ok ”。 value, ok := Interfacevariable.(implementType) 其中 Interfacevariable 是接口变量（接口值），implementType 为实现此接口的类型，value 返回接口变量实际类型变量的值，如果该类型实现了此接口返回 true。 //判断file1接口指向的对象实例是否是File类型 var file1 Writer=... if file5,ok:=file1.(File);ok{ ... } 1.5 接口类型查询 在 Go 中，要判断传递给接口值的变量类型，可以在使用 type switch 得到。(type)只能在 switch 中使用。 // 另一个实现了 I 接口的 R 类型 type R struct { i int } func (p *R) Get() int { return p.i } func (p *R) Put(v int) { p.i = v } func f(p I) { switch t := p.(type) { // 判断传递给 p 的实际类型 case *S: // 指向 S 的指针类型 case *R: // 指向 R 的指针类型 case S: // S 类型 case R: // R 类型 default: //实现了 I 接口的其他类型 } } 1.6 接口组合 //接口组合类似类型组合，只不过只包含方法，不包含成员变量 type ReadWriter interface{ //接口组合，避免代码重复 Reader //接口Reader Writer //接口Writer } 1.7 Any类型[空接口] 每种类型都能匹配到空接口：interface{}。空接口类型对方法没有任何约束（因为没有方法），它能包含任意类型，也可以实现到其他接口类型的转换。如果传递给该接口的类型变量实现了转换后的接口则可以正常运行，否则出现运行时错误。 //interface{}即为可以指向任何对象的Any类型，类似Java中的Object类 var v1 interface{}=struct{X int}{1} var v2 interface{}=\"abc\" func DoSomething(v interface{}) { //该函数可以接收任何类型的参数，因为任何类型都实现了空接口 // ... } 1.8 接口的代码示例 //接口animal type Animal interface { Speak() string } //Dog类实现animal接口 type Dog struct { } func (d Dog) Speak() string { return \"Woof!\" } //Cat类实现animal接口 type Cat struct { } func (c Cat) Speak() string { return \"Meow!\" } //Llama实现animal接口 type Llama struct { } func (l Llama) Speak() string { return \"?????\" } //JavaProgrammer实现animal接口 type JavaProgrammer struct { } func (j JavaProgrammer) Speak() string { return \"Design patterns!\" } //主函数 func main() { animals := []Animal{Dog{}, Cat{}, Llama{}, JavaProgrammer{}} //利用接口实现多态 for _, animal := range animals { fmt.Println(animal.Speak()) //打印不同实现该接口的类的方法返回值 } } 2. client-go中接口的使用分析 以下以k8s.io/client-go/kubernetes/typed/core/v1/pod.go的pod对象做分析。 2.1 接口设计与定义 2.1.1 接口组合 // PodsGetter has a method to return a PodInterface. // A group's client should implement this interface. type PodsGetter interface { Pods(namespace string) PodInterface } 2.1.2 接口定义 // PodInterface has methods to work with Pod resources. type PodInterface interface { Create(*v1.Pod) (*v1.Pod, error) Update(*v1.Pod) (*v1.Pod, error) UpdateStatus(*v1.Pod) (*v1.Pod, error) Delete(name string, options *meta_v1.DeleteOptions) error DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error Get(name string, options meta_v1.GetOptions) (*v1.Pod, error) List(opts meta_v1.ListOptions) (*v1.PodList, error) Watch(opts meta_v1.ListOptions) (watch.Interface, error) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.Pod, err error) PodExpansion } PodInterface接口定义了pod对象所使用的方法，一般为增删改查等。其他kubernetes资源对象的接口定义类似，区别在于入参和出参与对象相关。例如Create(*v1.Pod) (*v1.Pod, error)方法定义的入参出参为*v1.Pod。如果要实现该接口，即实现该接口的所有方法。 2.2 接口的实现 2.2.1 结构体的定义 // pods implements PodInterface type pods struct { client rest.Interface ns string } 2.2.2 new函数[构造函数] // newPods returns a Pods func newPods(c *CoreV1Client, namespace string) *pods { return &pods{ client: c.RESTClient(), ns: namespace, } } 2.2.3 方法的实现 Get // Get takes name of the pod, and returns the corresponding pod object, and an error if there is any. func (c *pods) Get(name string, options meta_v1.GetOptions) (result *v1.Pod, err error) { result = &v1.Pod{} err = c.client.Get(). Namespace(c.ns). Resource(\"pods\"). Name(name). VersionedParams(&options, scheme.ParameterCodec). Do(). Into(result) return } List // List takes label and field selectors, and returns the list of Pods that match those selectors. func (c *pods) List(opts meta_v1.ListOptions) (result *v1.PodList, err error) { result = &v1.PodList{} err = c.client.Get(). Namespace(c.ns). Resource(\"pods\"). VersionedParams(&opts, scheme.ParameterCodec). Do(). Into(result) return } Create // Create takes the representation of a pod and creates it. Returns the server's representation of the pod, and an error, if there is any. func (c *pods) Create(pod *v1.Pod) (result *v1.Pod, err error) { result = &v1.Pod{} err = c.client.Post(). Namespace(c.ns). Resource(\"pods\"). Body(pod). Do(). Into(result) return } Update // Update takes the representation of a pod and updates it. Returns the server's representation of the pod, and an error, if there is any. func (c *pods) Update(pod *v1.Pod) (result *v1.Pod, err error) { result = &v1.Pod{} err = c.client.Put(). Namespace(c.ns). Resource(\"pods\"). Name(pod.Name). Body(pod). Do(). Into(result) return } Delete // Delete takes name of the pod and deletes it. Returns an error if one occurs. func (c *pods) Delete(name string, options *meta_v1.DeleteOptions) error { return c.client.Delete(). Namespace(c.ns). Resource(\"pods\"). Name(name). Body(options). Do(). Error() } 2.3 接口的调用 示例： // 创建clientset实例 clientset, err := kubernetes.NewForConfig(config) // 具体的调用 pods, err := clientset.CoreV1().Pods(\"\").List(metav1.ListOptions{}) clientset实现了接口Interface，Interface是个接口组合，包含各个client的接口类型。例如CoreV1()方法对应的接口类型是CoreV1Interface。 以下是clientset的CoreV1()方法实现： // CoreV1 retrieves the CoreV1Client func (c *Clientset) CoreV1() corev1.CoreV1Interface { return c.coreV1 } 该方法可以理解为是一个构造函数。构造函数的返回值类型是一个接口类型CoreV1Interface，而return的返回值是实现了该接口类型的结构体对象c.coreV1。 接口类型是一种特殊的类型，接口类型与结构体对象之间的关系好比变量类型与变量之间的关系。其中的结构体对象必须实现了该接口类型的所有方法。 所以clientset的CoreV1()方法实现是返回一个CoreV1Client结构体对象。该结构体对象实现了CoreV1Interface接口，该接口也是一个接口组合。 type CoreV1Interface interface { RESTClient() rest.Interface ComponentStatusesGetter ConfigMapsGetter EndpointsGetter EventsGetter LimitRangesGetter NamespacesGetter NodesGetter PersistentVolumesGetter PersistentVolumeClaimsGetter PodsGetter PodTemplatesGetter ReplicationControllersGetter ResourceQuotasGetter SecretsGetter ServicesGetter ServiceAccountsGetter } 而实现的Pods()方法是其中的PodsGetter接口。 Pods()同CoreV1()一样是个构造函数，构造函数的返回值类型是PodInterface接口，返回值是实现了PodInterface接口的pods结构体对象。 func (c *CoreV1Client) Pods(namespace string) PodInterface { return newPods(c, namespace) } 而PodInterface接口定义参考接口定义，pods对象实现了PodInterface接口的方法，具体参考接口的实现。 最终调用了pods对象的List()方法。 pods, err := clientset.CoreV1().Pods(\"\").List(metav1.ListOptions{}) 即以上代码就是不断调用实现了某接口的结构体对象的构造函数，生成具体的结构体对象，再调用结构体对象的某个具体方法。 3. 通用接口设计 3.1 接口定义 // ProjectManager manage life cycle of Deployment and Resources type PodInterface interface { Create(*v1.Pod) (*v1.Pod, error) Update(*v1.Pod) (*v1.Pod, error) UpdateStatus(*v1.Pod) (*v1.Pod, error) Delete(name string, options *meta_v1.DeleteOptions) error DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error Get(name string, options meta_v1.GetOptions) (*v1.Pod, error) List(opts meta_v1.ListOptions) (*v1.PodList, error) Watch(opts meta_v1.ListOptions) (watch.Interface, error) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.Pod, err error) PodExpansion } 3.2 结构体定义 // pods implements PodInterface type pods struct { client rest.Interface ns string } 3.3 构造函数 // newPods returns a Pods func newPods(c *CoreV1Client, namespace string) *pods { return &pods{ client: c.RESTClient(), ns: namespace, } } 3.4 结构体实现 List() // List takes label and field selectors, and returns the list of Pods that match those selectors. func (c *pods) List(opts meta_v1.ListOptions) (result *v1.PodList, err error) { result = &v1.PodList{} err = c.client.Get(). Namespace(c.ns). Resource(\"pods\"). VersionedParams(&opts, scheme.ParameterCodec). Do(). Into(result) return } 3.5 接口调用 pods, err := clientset.CoreV1().Pods(\"\").List(metav1.ListOptions{}) 3.6 其他接口设计示例 type XxxManager interface { Create(args argsType) (*XxxStruct, error) Get(args argsType) (**XxxStruct, error) Update(args argsType) (*XxxStruct, error) Delete(name string, options *DeleleOptions) error } type XxxManagerImpl struct { Name string Namespace string kubeCli *kubernetes.Clientset } func NewXxxManagerImpl (namespace, name string, kubeCli *kubernetes.Clientset) XxxManager { return &XxxManagerImpl{ Name name, Namespace namespace, kubeCli: kubeCli, } } func (xm *XxxManagerImpl) Create(args argsType) (*XxxStruct, error) { //具体的方法实现 } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:36:37 "},"oop/pointer.html":{"url":"oop/pointer.html","title":"指针","keywords":"","body":"1. 指针的概念 概念 说明 变量 是一种占位符，用于引用计算机的内存地址。可理解为内存地址的标签 指针 表示内存地址，表示地址的指向。指针是一个指向另一个变量内存地址的值 & 取地址符，例如：{指针}:=&{变量} * 取值符，例如：{变量}:=*{指针} 2. 内存地址说明 2.1. 内存定义 计算机的内存 RAM 可以把它想象成一些有序的盒子，一个接一个的排成一排，每一个盒子或者单元格都被一个唯一的数字标记依次递增，这个数字就是该单元格的地址，也就是内存的地址。 硬件角度：内存是CPU沟通的桥梁，程序运行在内存中。 逻辑角度：内存是一块具备随机访问能力，支持读写操作，用来存放程序及程序运行中产生的数据的区域。 概念 比喻 内存 一层楼层 内存块 楼层中的一个房间 变量名 房间的标签，例如：总经理室 指针 房间的具体地址（门牌号），例如：总经理室地址是2楼201室 变量值 房间里的具体存储物 指针地址 指针的地址：存储指针内存块的地址 2.2. 内存单位和编址 2.2.1. 内存单位 单位 说明 位（bit） 计算机中最小的数据单位，每一位的状态只能是0或1 字节（Byte） 1Byte=8bit，是内存基本的计量单位 字 “字”由若干个字节构成，字的位数叫字长，不同档次的机器有不同的字长 KB 1KB=1024Byte，即1024个字节 MB 1MB=1024KB GB 1GB=1024MB 2.2.2. 内存编址 计算机中的内存按字节编址，每个地址的存储单元可以存放一个字节的数据，CPU通过内存地址获取指令和数据，并不关心这个地址所代表的空间在什么位置，内存地址和地址指向的空间共同构成了一个内存单元。 2.2.3. 内存地址 内存地址通常用16进制的数据表示，例如0x0ffc1。 3.变量与指针运算理解 编写一段程序，检索出值并存储在地址为 200 的一个块内存中，将其乘以 3，并将结果存储在地址为 201 的另一块内存中 3.1.本质 检索出内存地址为 200 的值，并将其存储在 CPU 中 将存储在 CPU 中的值乘以 3 将 CPU 中存储的结果，写入地址为 201 的内存块中 图片 - 什么是变量 3.2.基于变量的理解 获取变量 a 中存储的值，并将其存储在 CPU 中 将其乘以 3 将结果保存在变量 b 中 图片 - 什么是变量2 var a = 6 var b = a * 3 3.3.基于指针的理解 func main() { a := 200 b := &a *b++ fmt.Println(a) } 以上函数对a进行+1操作，具体理解如下： 1.a:=200 图片 - 什么是指针 2. b := &a 图片 - 什么是指针2 3. *b++ 图片 - 什么是指针3 图片 - 什么是指针4 4. 指针的使用 4.1. 方法中的指针 方法即为有接受者的函数，接受者可以是类型的实例变量或者是类型的实例指针变量。但两种效果不同。 1、类型的实例变量 func main(){ person := Person{\"vanyar\", 21} fmt.Printf(\"person\\n\", person.name, person.age) person.sayHi() person.ModifyAge(210) person.sayHi() } type Person struct { name string age int } func (p Person) sayHi() { fmt.Printf(\"SayHi -- This is %s, my age is %d\\n\",p.name, p.age) } func (p Person) ModifyAge(age int) { fmt.Printf(\"ModifyAge\") p.age = age } //输出结果 person SayHi -- This is vanyar, my age is 21 ModifyAgeSayHi -- This is vanyar, my age is 21 尽管 ModifyAge 方法修改了其age字段，可是方法里的p是person变量的一个副本，修改的只是副本的值。下一次调用sayHi方法的时候，还是person的副本，因此修改方法并不会生效。 即实例变量的方式并不会改变接受者本身的值。 2、类型的实例指针变量 func (p *Person) ChangeAge(age int) { fmt.Printf(\"ModifyAge\") p.age = age } Go会根据Person的示例类型，转换成指针类型再拷贝，即 person.ChangeAge会变成 (&person).ChangeAge。 指针类型的接受者，如果实例对象是值，那么go会转换成指针，然后再拷贝，如果本身就是指针对象，那么就直接拷贝指针实例。因为指针都指向一处值，就能修改对象了。 5. 零值与nil(空指针) 变量声明而没有赋值，默认为零值，不同类型零值不同，例如字符串零值为空字符串； 指针声明而没有赋值，默认为nil，即该指针没有任何指向。当指针没有指向的时候，不能对(*point)进行操作包括读取，否则会报空指针异常。 func main(){ // 声明一个指针变量 aPot 其类型也是 string var aPot *string fmt.Printf(\"aPot: %p %#v\\n\", &aPot, aPot) // 输出 aPot: 0xc42000c030 (*string)(nil) *aPot = \"This is a Pointer\" // 报错： panic: runtime error: invalid memory address or nil pointer dereference } 解决方法即给该指针分配一个指向,即初始化一个内存，并把该内存地址赋予指针变量，例如： // 声明一个指针变量 aPot 其类型也是 string var aPot *string fmt.Printf(\"aPot: %p %#v\\n\", &aPot, aPot) // 输出 aPot: 0xc42000c030 (*string)(nil) aPot = &aVar *aPot = \"This is a Pointer\" fmt.Printf(\"aVar: %p %#v \\n\", &aVar, aVar) // 输出 aVar: 0xc42000e240 \"This is a Pointer\" fmt.Printf(\"aPot: %p %#v %#v \\n\", &aPot, aPot, *aPot) // 输出 aPot: 0xc42000c030 (*string)(0xc42000e240) \"This is a Pointer\" 或者通过new开辟一个内存，并返回这个内存的地址。 var aNewPot *int aNewPot = new(int) *aNewPot = 217 fmt.Printf(\"aNewPot: %p %#v %#v \\n\", &aNewPot, aNewPot, *aNewPot) // 输出 aNewPot: 0xc42007a028 (*int)(0xc42006e1f0) 217 6. 总结 Golang提供了指针用于操作数据内存，并通过引用来修改变量。 只声明未赋值的变量，golang都会自动为其初始化为零值，基础数据类型的零值比较简单，引用类型和指针的零值都为nil，nil类型不能直接赋值，因此需要通过new开辟一个内存，或者通过make初始化数据类型，或者两者配合，然后才能赋值。 指针也是一种类型，不同于一般类型，指针的值是地址，这个地址指向其他的内存，通过指针可以读取其所指向的地址所存储的值。 函数方法的接受者，也可以是指针变量。无论普通接受者还是指针接受者都会被拷贝传入方法中，不同在于拷贝的指针，其指向的地方都一样，只是其自身的地址不一样。 参考： http://www.jianshu.com/p/d23f78a3922b http://www.jianshu.com/p/44b9429d7bef Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 18:09:14 "},"concurrency/concurrency.html":{"url":"concurrency/concurrency.html","title":"并发基础","keywords":"","body":"并发基础 1. 概念 并发意味着程序在运行时有多个执行上下文，对应多个调用栈。 并发与并行的区别： 并发的主流实现模型： 实现模型 说明 特点 多进程 操作系统层面的并发模式 处理简单，互不影响，但开销大 多线程 系统层面的并发模式 有效，开销较大，高并发时影响效率 基于回调的非阻塞/异步IO 多用于高并发服务器开发中 编程复杂，开销小 协程 用户态线程，不需要操作系统抢占调度，寄存于线程中 编程简单，结构简单，开销极小，但需要语言的支持 共享内存系统：线程之间采用共享内存的方式通信，通过加锁来避免死锁或资源竞争。 消息传递系统：将线程间共享状态封装在消息中，通过发送消息来共享内存，而非通过共享内存来通信。 2. 协程 执行体是个抽象的概念，在操作系统中分为三个级别：进程（process），进程内的线程（thread），进程内的协程（coroutine，轻量级线程）。协程的数量级可达到上百万个，进程和线程的数量级最多不超过一万个。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。 3. 并发通信 并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。Go语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:45:37 "},"concurrency/goroutine.html":{"url":"concurrency/goroutine.html","title":"Goroutine","keywords":"","body":"Goroutine //定义调用体 func Add(x,y int){ z:=x+y fmt.Println(z) } //go关键字执行调用，即会产生一个goroutine并发执行 //当函数返回时，goroutine自动结束，如果有返回值,返回值会自动被丢弃 go Add(1,1) //并发执行 func main(){ for i:=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:44:27 "},"concurrency/channel.html":{"url":"concurrency/channel.html","title":"Channel","keywords":"","body":"Channel channel就像管道的形式，是goroutine之间的通信方式，是进程内的通信方式，跨进程通信建议用分布式系统的方法来解决，例如Socket或http等通信协议。channel是类型相关，即一个channel只能传递一种类型的值，在声明时指定。 1. 基本语法 1.1. channel的声明 //1、channel声明，声明一个管道chanName，该管道可以传递的类型是ElementType //管道是一种复合类型，[chan ElementType],表示可以传递ElementType类型的管道[类似定语从句的修饰方法] var chanName chan ElementType var ch chan int //声明一个可以传递int类型的管道 var m map[string] chan bool //声明一个map，值的类型为可以传递bool类型的管道 1.2. 初始化 //2、初始化ch:=make(chan int) //make一般用来声明一个复合类型，参数为复合类型的属性 1.3. 管道读写 //3、管道写入,把值想象成一个球，\" 1.4. select //4、每个case必须是一个IO操作，面向channel的操作，只执行其中的一个case操作，一旦满足则结束select过程 //面向channel的操作无非三种情况：成功读出；成功写入；即没有读出也没有写入 select{ case 2. 缓冲和超时机制 2.1. 缓冲机制 //1、缓冲机制：为管道指定空间长度，达到类似消息队列的效果 c:=make(chan int,1024) //第二个参数为缓冲区大小，与切片的空间大小类似 //通过range关键字来实现依次读取管道的数据，与数组或切片的range使用方法类似 for i :=range c{ fmt.Println(\"Received:\",i) } 2.2. 超时机制 //2、超时机制：利用select只要一个case满足，程序就继续执行而不考虑其他case的情况的特性实现超时机制 timeout:=make(chan bool,1) //设置一个超时管道 go func(){ time.Sleep(1e9) //设置超时时间，等待一分钟 timeout 2.3. channel的传递 //1、channel的传递，来实现Linux系统中管道的功能，以插件的方式增加数据处理的流程 type PipeData struct{ value int handler func(int) int //handler是属性？ next chan int //可以把[chan int]看成一个整体，表示放int类型的管道 } func handler(queue chan *PipeData){ //queue是一个存放*PipeDate类型的管道，可改变管道里的数据块内容 for data:=range queue{ //data的类型就是管道存放定义的类型，即PipeData data.next 2.4. 单向channel //2、单向channel：只能用于接收或发送数据，是对channel的一种使用限制 //单向channel的声明 var ch1 chan int //正常channel，可读写 var ch2 chan 2.5. 关闭channel //3、关闭channel，使用内置函数close()函数即可 close(ch) //判断channel是否关闭 x,ok:= Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:44:10 "},"concurrency/parallelization.html":{"url":"concurrency/parallelization.html","title":"并行化","keywords":"","body":"多核并行化与同步锁 1. 多核并行化 //多核并行化 runtime.GOMAXPROCS(16) //设置环境变量GOMAXPROCS的值来控制使用多少个CPU核心 runtime.NumCPU() //来获取核心数 //出让时间片 runtime.Gosched() //在每个goroutine中控制何时出让时间片给其他goroutine 2. 同步锁 //同步锁 sync.Mutex //单读单写：占用Mutex后，其他goroutine只能等到其释放该Mutex sync.RWMutex //单写多读：会阻止写，不会阻止读 RLock() //读锁 Lock() //写锁 RUnlock() //解锁（读锁） Unlock() //解锁（写锁） //全局唯一性操作 //once的Do方法保证全局只调用指定函数(setup)一次，其他goroutine在调用到此函数是会阻塞，直到once调用结束才继续 once.Do(setup) Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-19 17:42:43 "},"text/json.html":{"url":"text/json.html","title":"Json处理","keywords":"","body":"JSON处理 JSON是一种轻量级的数据交换语言。 1. 解析JSON[Unmarshal(data []byte, v interface{})] 1.1. Unmarshal源码 /src/encoding/json/decode.go func Unmarshal(data []byte, v interface{}) error { // Check for well-formedness. // Avoids filling out half a data structure // before discovering a JSON syntax error. var d decodeState err := checkValid(data, &d.scan) if err != nil { return err } d.init(data) return d.unmarshal(v) } ... func (d *decodeState) unmarshal(v interface{}) (err error) { defer func() { if r := recover(); r != nil { if _, ok := r.(runtime.Error); ok { panic(r) } err = r.(error) } }() rv := reflect.ValueOf(v) if rv.Kind() != reflect.Ptr || rv.IsNil() { return &InvalidUnmarshalError{reflect.TypeOf(v)} } d.scan.reset() // We decode rv not rv.Elem because the Unmarshaler interface // test must be applied at the top level of the value. d.value(rv) return d.savedError } 1.2. 解析到结构体 package main import ( \"encoding/json\" \"fmt\" ) type Server struct { ServerName string ServerIP string } type Serverslice struct { Servers []Server } func main() { var s Serverslice str := `{\"servers\": [{\"serverName\":\"Shanghai_VPN\",\"serverIP\":\"127.0.0.1\"}, {\"serverName\":\"Beijing_VPN\",\"serverIP\":\"127.0.0.2\"}]}` err:=json.Unmarshal([]byte(str), &s) if err!=nil{ fmt.Println(err) } fmt.Println(s) } 说明 JSON格式与结构体一一对应，Unmarshal方法即将JSON文本转换成结构体。只会匹配结构体中的可导出字段，即首字母大写字段（类似java的public），匹配规则如下：json的key为Foo为例 先查找struct tag中含有Foo的可导出的struct字段（首字母大写） 其次查找字段名为Foo的可导出字段。 最后查找类似FOO或者FoO这类除首字母外，其他大小写不敏感的可导出字段。 1.3. 解析到interface 2. 生成JSON[Marshal(v interface{})] 2.1. Marshal源码 /src/encoding/json/encode.go func Marshal(v interface{}) ([]byte, error) { e := &encodeState{} err := e.marshal(v) if err != nil { return nil, err } return e.Bytes(), nil } ... func (e *encodeState) marshal(v interface{}) (err error) { defer func() { if r := recover(); r != nil { if _, ok := r.(runtime.Error); ok { panic(r) } if s, ok := r.(string); ok { panic(s) } err = r.(error) } }() e.reflectValue(reflect.ValueOf(v)) return nil } 2.2. 使用方法 package main import ( \"encoding/json\" \"fmt\" ) type Server struct { ServerName string `json:\"serverName,string\"` ServerIP string `json:\"serverIP,omitempty\"` } type Serverslice struct { Servers []Server `json:\"servers\"` } func main() { var s Serverslice s.Servers = append(s.Servers, Server{ServerName: \"Shanghai_VPN\", ServerIP: \"127.0.0.1\"}) s.Servers = append(s.Servers, Server{ServerName: \"Beijing_VPN\", ServerIP: \"127.0.02\"}) b, err := json.Marshal(s) if err != nil { fmt.Println(\"JSON ERR:\", err) } fmt.Println(string(b)) } 2.3. 说明 Marshal方法将结构体转换成json文本，匹配规则如下： 如果字段的tag是“-”，那么该字段不会输出到JSON。 如果tag中带有自定义名称，那么该自定义名称会出现在JSON字段名中。例如例子中的“serverName” 如果tag中带有“omitempty”选项，那么如果该字段值为空，就不会输出到JSON中。 如果字段类型是bool,string,int,int64等，而tag中带有“，string”选项，那么这个字段在输出到JSON的时候会把该字段对应的值转换成JSON字符串。 注意事项： Marshal只有在转换成功的时候才会返回数据，JSON对象只支持string作为key，如果要编码一个map,那么必须是map[string]T这种类型。（T为任意类型） Channel,complex和function不能被编码成JSON。 嵌套的数据不能编码，会进入死循环。 指针在编码时会输出指针指向的内容，而空指针会输出null。 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:29:10 "},"text/file.html":{"url":"text/file.html","title":"文件操作","keywords":"","body":"文件操作 更多文件操作见Go的os包。 1. 目录操作 func Mkdir(name string, perm FileMode) error创建名称为 name 的目录，权限设置是 perm，例如 0777 func MkdirAll(path string, perm FileMode) error 根据 path 创建多级子目录，例如 astaxie/test1/test2。 func Remove(name string) error 删除名称为 name 的目录，当目录下有文件或者其他目录是会出错 func RemoveAll(path string) error 根据 path 删除多级子目录，如果 path 是单个名称，那么该目录不删除 2. 文件操作 2.1. 建立与打开文件 新建文件： func Create(name string) (file *File, err Error) 根据提供的文件名创建新的文件，返回一个文件对象，默认权限是 0666 的文件，返回的文件对象是可读写的。 func NewFile(fd uintptr, name string) *File 根据文件描述符创建相应的文件，返回一个文件对象 打开文件： func Open(name string) (file *File, err Error) 该方法打开一个名称为 name 的文件，但是是只读方式，内部实现其实调用了 OpenFile。 func OpenFile(name string, flag int, perm uint32) (file *File, err Error) 打开名称为 name 的文件，flag 是打开的方式，只读、读写等，perm 是权限 2.2. 写文件 写文件函数： func (file *File) Write(b []byte) (n int, err Error) 写入 byte 类型的信息到文件 func (file *File) WriteAt(b []byte, off int64) (n int, err Error) 在指定位置开始写入 byte 类型的信息 func (file *File) WriteString(s string) (ret int, err Error) 写入 string 信息到文件 package main import ( \"fmt\" \"os\" ) func main() { userFile := \"test.txt\" fout, err := os.Create(userFile) defer fout.Close() if err != nil { fmt.Println(userFile, err) return } for i := 0; i 2.3. 读文件 读文件函数： func (file *File) Read(b []byte) (n int, err Error) 读取数据到 b 中 func (file *File) ReadAt(b []byte, off int64) (n int, err Error) 从 off 开始读取数据到 b 中 package main import ( \"fmt\" \"os\" ) func main() { userFile := \"text.txt\" fl, err := os.Open(userFile) defer fl.Close() if err != nil { fmt.Println(userFile, err) return } buf := make([]byte, 1024) for { n, _ := fl.Read(buf) if 0 == n { break } os.Stdout.Write(buf[:n]) } } 2.4. 删除文件 Go 语言里面删除文件和删除文件夹是同一个函数 func Remove(name string) Error 调用该函数就可以删除文件名为 name 的文件 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:30:14 "},"text/string.html":{"url":"text/string.html","title":"字符串处理","keywords":"","body":"字符串处理 字符串操作涉及的标准库有strings和strconv两个包 1. 字符串操作 函数 说明 func Contains(s, substr string) bool 字符串 s 中是否包含 substr，返回 bool 值 func Join(a []string, sep string) string 字符串链接，把 slice a 通过 sep 链接起来 func Index(s, sep string) int 在字符串 s 中查找 sep 所在的位置，返回位置值，找不到返回-1 func Repeat(s string, count int) string 重复 s 字符串 count 次，最后返回重复的字符串 func Replace(s, old, new string, n int) string 在 s 字符串中，把 old 字符串替换为 new 字符串，n 表示替换的次数，小于 0 表示全部替换 func Split(s, sep string) []string 把 s 字符串按照 sep 分割，返回 slice func Trim(s string, cutset string) string 在 s 字符串中去除 cutset 指定的字符串 func Fields(s string) []string 去除 s 字符串的空格符，并且按照空格分割返回 slice 2. 字符串转换 1、Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中 package main import ( \"fmt\" \"strconv\" ) func main() { str := make([]byte, 0, 100) str = strconv.AppendInt(str, 4567, 10) str = strconv.AppendBool(str, false) str = strconv.AppendQuote(str, \"abcdefg\") str = strconv.AppendQuoteRune(str, '单') fmt.Println(string(str)) } 2、Format 系列函数把其他类型的转换为字符串 package main import ( \"fmt\" \"strconv\" ) func main() { a := strconv.FormatBool(false) b := strconv.FormatFloat(123.23, 'g', 12, 64) c := strconv.FormatInt(1234, 10) d := strconv.FormatUint(12345, 10) e := strconv.Itoa(1023) fmt.Println(a, b, c, d, e) } 3、Parse 系列函数把字符串转换为其他类型 package main import ( \"fmt\" \"strconv\" ) func main() { a, err := strconv.ParseBool(\"false\") if err != nil { fmt.Println(err) } b, err := strconv.ParseFloat(\"123.23\", 64) if err != nil { fmt.Println(err) } c, err := strconv.ParseInt(\"1234\", 10, 64) if err != nil { fmt.Println(err) } d, err := strconv.ParseUint(\"12345\", 10, 64) if err != nil { fmt.Println(err) } e, err := strconv.Itoa(\"1023\") if err != nil { fmt.Println(err) } fmt.Println(a, b, c, d, e) } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:30:37 "},"text/template.html":{"url":"text/template.html","title":"模板语法","keywords":"","body":"基本语法 go 统一使用了 {{ 和 }} 作为左右标签，没有其他的标签符号。 使用 . 来访问当前位置的上下文 使用 $ 来引用当前模板根级的上下文 使用 $var 来访问创建的变量 模板中支持的 go 语言符号 {{\"string\"}} // 一般 string {{`raw string`}} // 原始 string {{'c'}} // byte {{print nil}} // nil 也被支持 模板中的 pipeline 可以是上下文的变量输出，也可以是函数通过管道传递的返回值 {{. | FuncA | FuncB | FuncC}} 当 pipeline 的值等于: false 或 0 nil 的指针或 interface 长度为 0 的 array, slice, map, string 那么这个 pipeline 被认为是空 1. if … else … end {{if pipeline}}{{end}} if 判断时，pipeline 为空时，相当于判断为 False 支持嵌套的循环 {{if .IsHome}} {{else}} {{if .IsAbout}}{{end}} {{end}} 也可以使用 else if 进行 {{if .IsHome}} {{else if .IsAbout}} {{else}} {{end}} 2. range … end {{range pipeline}}{{.}}{{end}} pipeline 支持的类型为 array, slice, map, channel range 循环内部的 . 改变为以上类型的子元素 对应的值长度为 0 时，range 不会执行，. 不会改变。 pages := []struct { Num int }{{10}, {20}, {30}} this.Data[\"Total\"] = 100 this.Data[\"Pages\"] = pages 使用 .Num 输出子元素的 Num 属性，使用 $. 引用模板中的根级上下文 {{range .Pages}} {{.Num}} of {{$.Total}} {{end}} 使用创建的变量，在这里和 go 中的 range 用法是相同的。 {{range $index, $elem := .Pages}} {{$index}} - {{$elem.Num}} - {{.Num}} of {{$.Total}} {{end}} range 也支持 else {{range .Pages}} {{else}} {{/* 当 .Pages 为空 或者 长度为 0 时会执行这里 */}} {{end}} 3. with … end {{with pipeline}}{{end}} with 用于重定向 pipeline {{with .Field.NestField.SubField}} {{.Var}} {{end}} 也可以对变量赋值操作 {{with $value := \"My name is %s\"}} {{printf . \"slene\"}} {{end}} with 也支持 else {{with pipeline}} {{else}} {{/* 当 pipeline 为空时会执行这里 */}} {{end}} 4. define define 可以用来定义自模板，可用于模块定义和模板嵌套 {{define \"loop\"}} {{.Name}} {{end}} 使用 template 调用模板 {{range .Items}} {{template \"loop\" .}} {{end}} 5. template {{template \"模板名\" pipeline}} 将对应的上下文 pipeline 传给模板，才可以在模板中调用 Beego 中支持直接载入文件模板 {{template \"path/to/head.html\" .}} Beego 会依据你设置的模板路径读取 head.html 在模板中可以接着载入其他模板，对于模板的分模块处理很有用处 6. 注释 允许多行文本注释，不允许嵌套 {{/* comment content support new line */ Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:40:16 "},"test/test.html":{"url":"test/test.html","title":"单元测试","keywords":"","body":"1. Go中的测试框架 Go语言中自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，你可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。 2. 单元测试原则 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。 3. 示例 3.1. 源文件getest.go package gotest import ( \"errors\" ) func Division(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(\"除数不能为0\") } return a / b, nil } 3.2. 测试文件gotest_test.go func Test_Division_2(t *testing.T) { if _, e := Division(6, 0); e == nil { //try a unit test on function t.Error(\"Division did not work as expected.\") // 如果不是如预期的那么就报错 } else { t.Log(\"one test passed.\", e) //记录一些你期望记录的信息 } } 4. 压力测试 压力测试用来检测函数(方法）的性能，和编写单元功能测试的方法类似。 压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母 func BenchmarkXXX(b *testing.B) { ... } go test不会默认执行压力测试的函数，如果要执行压力测试需要带上参数-test.bench，语法:-test.bench=\"test_name_regex\",例如go test -test.bench=\".*\"表示测试全部的压力测试函数 在压力测试用例中,请记得在循环体内使用testing.B.N,以使测试可以正常的运行 文件名也必须以_test.go结尾 4.1. 示例 package gotest import ( \"testing\" ) func Benchmark_Division(b *testing.B) { for i := 0; i 执行测试命令 go test -file webbench_test.go -test.bench=\".*\" Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:42:56 "},"test/gbd.html":{"url":"test/gbd.html","title":"GDB调试","keywords":"","body":"1. GDB简介 GDB是FSF(自由软件基金会)发布的一个强大的类UNIX系统下的程序调试工具。使用GDB可以做如下事情： 启动程序，可以按照开发者的自定义要求运行程序。 可让被调试的程序在开发者设定的调置的断点处停住。（断点可以是条件表达式） 当程序被停住时，可以检查此时程序中所发生的事。 动态的改变当前程序的执行环境。 目前支持调试Go程序的GDB版本必须大于7.1。 编译Go程序的时候需要注意以下几点 传递参数-ldflags \"-s\"，忽略debug的打印信息 传递-gcflags \"-N -l\" 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。 2. 常用命令 2.1. list 简写命令l，用来显示源代码，默认显示十行代码，后面可以带上参数显示的具体行，例如：list 15，显示十行代码，其中第15行在显示的十行里面的中间，如下所示。 10 time.Sleep(2 * time.Second) 11 c 2.2. break 简写命令 b,用来设置断点，后面跟上参数设置断点的行数，例如b 10在第十行设置断点。 2.3. delete 简写命令 d,用来删除断点，后面跟上断点设置的序号，这个序号可以通过info breakpoints获取相应的设置的断点序号，如下是显示的设置断点序号。 Num Type Disp Enb Address What 2 breakpoint keep y 0x0000000000400dc3 in main.main at /home/xiemengjun/gdb.go:23 breakpoint already hit 1 time 2.4. backtrace 简写命令 bt,用来打印执行的代码过程，如下所示： #0 main.main () at /home/xiemengjun/gdb.go:23 #1 0x000000000040d61e in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244 #2 0x000000000040d6c1 in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267 #3 0x0000000000000000 in ?? () 2.5. info info命令用来显示信息，后面有几种参数，我们常用的有如下几种： info locals 显示当前执行的程序中的变量值 info breakpoints 显示当前设置的断点列表 info goroutines 显示当前执行的goroutine列表，如下代码所示,带*的表示当前执行的 * 1 running runtime.gosched * 2 syscall runtime.entersyscall 3 waiting runtime.gosched 4 runnable runtime.gosched 2.6. print 简写命令p，用来打印变量或者其他信息，后面跟上需要打印的变量名，当然还有一些很有用的函数$len()和$cap()，用来返回当前string、slices或者maps的长度和容量。 2.7. whatis 用来显示当前变量的类型，后面跟上变量名，例如whatis msg,显示如下： type = struct string 2.8. next 简写命令 n,用来单步调试，跳到下一步，当有断点之后，可以输入n跳转到下一步继续执行 2.9. coutinue 简称命令 c，用来跳出当前断点处，后面可以跟参数N，跳过多少次断点 2.10. set variable 该命令用来改变运行过程中的变量值，格式如：set variable = 3. 调试过程 3.1. 示例代码 package main import ( \"fmt\" \"time\" ) func counting(c chan 3.2. 调试步骤 编译文件，生成可执行文件gdbfile: go build -gcflags \"-N -l\" gdbfile.go 通过gdb命令启动调试： gdb gdbfile 启动之后首先看看这个程序是不是可以运行起来，只要输入run命令回车后程序就开始运行，程序正常的话可以看到程序输出如下，和我们在命令行直接执行程序输出是一样的： (gdb) run Starting program: /home/xiemengjun/gdbfile Starting main count: 0 count: 1 count: 2 count: 3 count: 4 count: 5 count: 6 count: 7 count: 8 count: 9 [LWP 2771 exited] [Inferior 1 (process 2771) exited normally] 好了，现在我们已经知道怎么让程序跑起来了，接下来开始给代码设置断点： (gdb) b 23 Breakpoint 1 at 0x400d8d: file /home/xiemengjun/gdbfile.go, line 23. (gdb) run Starting program: /home/xiemengjun/gdbfile Starting main [New LWP 3284] [Switching to LWP 3284] Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(\"count:\", count) 上面例子b 23表示在第23行设置了断点，之后输入run开始运行程序。现在程序在前面设置断点的地方停住了，我们需要查看断点相应上下文的源码，输入list就可以看到源码显示从当前停止行的前五行开始： (gdb) list 18 fmt.Println(msg) 19 bus := make(chan int) 20 msg = \"starting a gofunc\" 21 go counting(bus) 22 for count := range bus { 23 fmt.Println(\"count:\", count) 24 } 25 } 现在GDB在运行当前的程序的环境中已经保留了一些有用的调试信息，我们只需打印出相应的变量，查看相应变量的类型及值： (gdb) info locals count = 0 bus = 0xf840001a50 (gdb) p count $1 = 0 (gdb) p bus $2 = (chan int) 0xf840001a50 (gdb) whatis bus type = chan int 接下来该让程序继续往下执行，请继续看下面的命令 (gdb) c Continuing. count: 0 [New LWP 3303] [Switching to LWP 3303] Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(\"count:\", count) (gdb) c Continuing. count: 1 [Switching to LWP 3302] Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(\"count:\", count) 每次输入c之后都会执行一次代码，又跳到下一次for循环，继续打印出来相应的信息。设想目前需要改变上下文相关变量的信息，跳过一些过程，并继续执行下一步，得出修改后想要的结果： (gdb) info locals count = 2 bus = 0xf840001a50 (gdb) set variable count=9 (gdb) info locals count = 9 bus = 0xf840001a50 (gdb) c Continuing. count: 9 [Switching to LWP 3302] Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23 23 fmt.Println(\"count:\", count) 最后稍微思考一下，前面整个程序运行的过程中到底创建了多少个goroutine，每个goroutine都在做什么： (gdb) info goroutines * 1 running runtime.gosched * 2 syscall runtime.entersyscall 3 waiting runtime.gosched 4 runnable runtime.gosched (gdb) goroutine 1 bt #0 0x000000000040e33b in runtime.gosched () at /home/xiemengjun/go/src/pkg/runtime/proc.c:927 #1 0x0000000000403091 in runtime.chanrecv (c=void, ep=void, selected=void, received=void) at /home/xiemengjun/go/src/pkg/runtime/chan.c:327 #2 0x000000000040316f in runtime.chanrecv2 (t=void, c=void) at /home/xiemengjun/go/src/pkg/runtime/chan.c:420 #3 0x0000000000400d6f in main.main () at /home/xiemengjun/gdbfile.go:22 #4 0x000000000040d0c7 in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244 #5 0x000000000040d16a in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267 #6 0x0000000000000000 in ?? () 通过查看goroutines的命令我们可以清楚地了解goruntine内部是怎么执行的，每个函数的调用顺序已经明明白白地显示出来了。 参考《Go Web编程》 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2018-08-22 20:58:19 "}}